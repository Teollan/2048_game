{"mappings":"A,I,E,C,EEEA,MAAM,EAAY,OAAO,MAAM,CAAC,CAC9B,mBAAoB,EACpB,YAAa,OACb,eAAgB,UAChB,WAAY,MACZ,YAAa,OACb,oBAAqB,OAAO,MAAM,CAAC,CACjC,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACb,CACH,GDTM,IAAA,EAAA,ACihBN,CAAA,EAAiB,CACf,KAvgBF,MAeE,YAAY,EAAe,EAAU,mBAAmB,CAAE,CACxD,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,EAAU,WAAW,CACnC,IAAI,CAAC,YAAY,CAAG,EAAE,CACtB,IAAI,CAAC,YAAY,CAAG,EAAE,CAEtB,IAAK,IAAI,EAAM,EAAG,EAAM,EAAU,kBAAkB,CAAE,IAAO,CAC3D,IAAI,CAAC,YAAY,CAAC,EAAI,CAAG,EAAE,CAC3B,IAAI,CAAC,YAAY,CAAC,EAAI,CAAG,EAAE,CAE3B,IAAK,IAAI,EAAS,EAAG,EAAS,EAAU,kBAAkB,CAAE,IAC1D,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAO,CAAG,CAAY,CAAC,EAAI,CAAC,EAAO,CAC1D,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAO,CAAG,CAAY,CAAC,EAAI,CAAC,EAAO,AAE9D,CACF,CAMA,UAAW,CACT,GAAI,IAAI,CAAC,SAAS,KAAO,EAAU,cAAc,CAC/C,OAGF,IAAI,EAAY,CAAA,EAEhB,IACE,IAAI,EAAW,EACf,EAAW,EAAU,kBAAkB,CACvC,IACA,CACA,IAAM,EAAM,IAAI,CAAC,MAAM,CAAC,GAElB,EAAmB,IAAI,CAAC,WAAW,CAAC,GAErC,IAAI,CAAC,aAAa,CAAC,EAAK,EAAiB,SAAS,IACrD,EAAY,CAAA,EAEZ,IAAI,CAAC,MAAM,CAAC,EAAU,EAAiB,SAAS,EAChD,IAAI,CAAC,KAAK,EAAI,EAAiB,KAAK,CAExC,CAEK,IACH,IAAI,CAAC,gBAAgB,CAAC,GACtB,IAAI,CAAC,YAAY,GAErB,CAMA,WAAY,CACV,GAAI,IAAI,CAAC,SAAS,KAAO,EAAU,cAAc,CAC/C,OAGF,IAAI,EAAY,CAAA,EAEhB,IACE,IAAI,EAAW,EACf,EAAW,EAAU,kBAAkB,CACvC,IACA,CACA,IAAM,EAAM,IAAI,CAAC,MAAM,CAAC,GAElB,EAAmB,IAAI,CAAC,WAAW,CAAC,EAAI,OAAO,IAEhD,IAAI,CAAC,aAAa,CAAC,EAAK,EAAiB,SAAS,IACrD,EAAY,CAAA,EAEZ,IAAI,CAAC,MAAM,CAAC,EAAU,EAAiB,SAAS,CAAC,OAAO,IACxD,IAAI,CAAC,KAAK,EAAI,EAAiB,KAAK,CAExC,CAEK,IACH,IAAI,CAAC,gBAAgB,CAAC,GACtB,IAAI,CAAC,YAAY,GAErB,CAMA,QAAS,CACP,GAAI,IAAI,CAAC,SAAS,KAAO,EAAU,cAAc,CAC/C,OAGF,IAAI,EAAY,CAAA,EAEhB,IACE,IAAI,EAAc,EAClB,EAAc,EAAU,kBAAkB,CAC1C,IACA,CACA,IAAM,EAAS,IAAI,CAAC,SAAS,CAAC,GAExB,EAAmB,IAAI,CAAC,WAAW,CAAC,GAErC,IAAI,CAAC,aAAa,CAAC,EAAQ,EAAiB,SAAS,IACxD,EAAY,CAAA,EAEZ,IAAI,CAAC,SAAS,CAAC,EAAa,EAAiB,SAAS,EACtD,IAAI,CAAC,KAAK,EAAI,EAAiB,KAAK,CAExC,CAEK,IACH,IAAI,CAAC,gBAAgB,CAAC,GACtB,IAAI,CAAC,YAAY,GAErB,CAMA,UAAW,CACT,GAAI,IAAI,CAAC,SAAS,KAAO,EAAU,cAAc,CAC/C,OAGF,IAAI,EAAY,CAAA,EAEhB,IACE,IAAI,EAAc,EAClB,EAAc,EAAU,kBAAkB,CAC1C,IACA,CACA,IAAM,EAAS,IAAI,CAAC,SAAS,CAAC,GAExB,EAAmB,IAAI,CAAC,WAAW,CAAC,EAAO,OAAO,IAEnD,IAAI,CAAC,aAAa,CAAC,EAAQ,EAAiB,SAAS,IACxD,EAAY,CAAA,EAEZ,IAAI,CAAC,SAAS,CAAC,EAAa,EAAiB,SAAS,CAAC,OAAO,IAC9D,IAAI,CAAC,KAAK,EAAI,EAAiB,KAAK,CAExC,CAEK,IACH,IAAI,CAAC,gBAAgB,CAAC,GACtB,IAAI,CAAC,YAAY,GAErB,CAKA,UAAW,CACT,OAAO,IAAI,CAAC,KAAK,AACnB,CAKA,UAAW,CACT,IAAM,EAAS,AAAI,MAAM,EAAU,kBAAkB,EAErD,IAAK,IAAI,EAAM,EAAG,EAAM,EAAU,kBAAkB,CAAE,IAAO,CAC3D,CAAM,CAAC,EAAI,CAAG,AAAI,MAAM,EAAU,kBAAkB,EAEpD,IAAK,IAAI,EAAS,EAAG,EAAS,EAAU,kBAAkB,CAAE,IAC1D,CAAM,CAAC,EAAI,CAAC,EAAO,CAAG,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAO,AAExD,CAEA,OAAO,CACT,CAYA,WAAY,CACV,OAAO,IAAI,CAAC,MAAM,AACpB,CAKA,OAAQ,CACN,IAAI,CAAC,MAAM,CAAG,EAAU,cAAc,CACtC,IAAI,CAAC,KAAK,CAAG,EAEb,IAAI,CAAC,gBAAgB,CAAC,EACxB,CAKA,SAAU,CACR,IAAK,IAAI,EAAM,EAAG,EAAM,EAAU,kBAAkB,CAAE,IACpD,IAAK,IAAI,EAAS,EAAG,EAAS,EAAU,kBAAkB,CAAE,IAC1D,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAO,CAAG,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAO,AAInE,CAAA,IAAI,CAAC,MAAM,CAAG,EAAU,WAAW,CACnC,IAAI,CAAC,KAAK,CAAG,CACf,CAMA,UAAU,CAAK,CAAE,CACf,IAAM,EAAS,AAAI,MAAM,EAAU,kBAAkB,EAErD,IAAK,IAAI,EAAM,EAAG,EAAM,EAAU,kBAAkB,CAAE,IACpD,CAAM,CAAC,EAAI,CAAG,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAM,CAG7C,OAAO,CACT,CAMA,UAAU,CAAK,CAAE,CAAM,CAAE,CACvB,IAAK,IAAI,EAAM,EAAG,EAAM,EAAU,kBAAkB,CAAE,IACpD,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAM,CAAG,CAAM,CAAC,EAAI,AAE/C,CAOA,OAAO,CAAK,CAAE,CACZ,IAAM,EAAM,AAAI,MAAM,EAAU,kBAAkB,EAElD,IAAK,IAAI,EAAS,EAAG,EAAS,EAAU,kBAAkB,CAAE,IAC1D,CAAG,CAAC,EAAO,CAAG,IAAI,CAAC,YAAY,CAAC,EAAM,CAAC,EAAO,CAGhD,OAAO,CACT,CAOA,OAAO,CAAK,CAAE,CAAG,CAAE,CACjB,IAAK,IAAI,EAAS,EAAG,EAAS,EAAU,kBAAkB,CAAE,IAC1D,IAAI,CAAC,YAAY,CAAC,EAAM,CAAC,EAAO,CAAG,CAAG,CAAC,EAAO,AAElD,CAOA,UAAW,CAGT,OAFc,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,EAAK,IAAQ,IAAI,KAAQ,EAAI,CAAE,EAAE,CAG3E,CAcA,iBAAkB,CAYhB,OAXqB,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC,CAAC,EAAO,KAC/C,IAAM,EAAS,EAAQ,EAAU,kBAAkB,CAGnD,MAAO,CACL,IAHU,AAAC,CAAA,EAAQ,CAAA,EAAU,EAAU,kBAAkB,CAIzD,OAAA,EACA,MAAA,CACF,CACF,EAGF,CASA,QAAQ,CAAG,CAAE,CAAM,CAAE,CACnB,OAAO,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAO,AACvC,CASA,QAAQ,CAAG,CAAE,CAAM,CAAE,CAAK,CAAE,CAC1B,IAAI,CAAC,YAAY,CAAC,EAAI,CAAC,EAAO,CAAG,CACnC,CAOA,iBAAiB,CAAK,CAAE,CACtB,IAAM,EAAa,IAAI,CAAC,eAAe,GAAG,MAAM,CAC9C,CAAC,CAAA,MAAE,CAAK,CAAE,GAAK,AAAU,IAAV,GAGjB,IAAK,IAAI,EAAI,EACX,AADc,EAAI,GACd,AAAsB,IAAtB,EAAW,MAAM,CADI,IAAK,CAK9B,IAAM,EAAQ,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAW,MAAM,EACpD,CAAA,IAAE,CAAG,CAAA,OAAE,CAAM,CAAE,CAAG,CAAU,CAAC,EAAM,CAEzC,EAAW,MAAM,CAAC,EAAO,GAEzB,IAAI,CAAC,OAAO,CAAC,EAAK,EAAQ,IAAI,CAAC,iBAAiB,GAClD,CACF,CAOA,mBAAoB,QAGlB,AAAI,AAFM,KAAK,MAAM,GAEb,GACC,EAGF,CACT,CAcA,YAAY,CAAI,CAAE,CAChB,IAAM,EAAU,EAAK,MAAM,CAAC,AAAC,GAAS,AAAS,IAAT,GAEtC,GAAI,EAAQ,MAAM,CAAG,EAGnB,OAFA,IAAI,CAAC,YAAY,CAAC,GAEX,CACL,UAAW,EACX,MAAO,CACT,EAGF,IAAM,EAAmB,EAAE,CACvB,EAAkB,EAEtB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,IAAK,CACvC,IAAM,EAAU,CAAO,CAAC,EAAE,AAGtB,CAAA,IAFS,CAAO,CAAC,EAAI,EAAE,EAGzB,EAAiB,IAAI,CAAC,AAAU,EAAV,GACtB,GAAmB,AAAU,EAAV,EACnB,KAEA,EAAiB,IAAI,CAAC,EAE1B,CAIA,OAFA,IAAI,CAAC,YAAY,CAAC,GAEX,CACL,UAAW,EACX,MAAO,CACT,CACF,CAUA,cAAc,CAAC,CAAE,CAAC,CAAE,CAClB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAU,kBAAkB,CAAE,IAChD,GAAI,CAAC,CAAC,EAAE,GAAK,CAAC,CAAC,EAAE,CACf,MAAO,CAAA,EAIX,MAAO,CAAA,CACT,CAOA,aAAa,CAAI,CAAE,CACjB,KAAO,EAAK,MAAM,CAAG,EAAU,kBAAkB,EAC/C,EAAK,IAAI,CAAC,GAGZ,OAAO,CACT,CAKA,cAAe,CA+Cb,IAAM,EAAQ,IAAI,CAAC,QAAQ,GA7ClB,AA+CQ,EA/CA,IAAI,CAAC,AAAC,GAAW,AAAW,OAAX,GAgDhC,IAAI,CAAC,MAAM,CAAG,EAAU,UAAU,CACzB,AA9CX,SAAuB,CAAO,EAE5B,GAAI,EAAQ,IAAI,CAAC,AAAC,GAAW,AAAW,IAAX,GAC3B,MAAO,CAAA,EAIT,IAAK,IAAI,EAAM,EAAG,EAAM,EAAU,kBAAkB,CAAE,IACpD,IACE,IAAI,EAAS,EACb,EAAS,EAAU,kBAAkB,CAAG,EACxC,IAOA,GAAI,AALY,CAAO,CAAC,EAAM,EAAU,kBAAkB,CAAG,EAAO,GAGhE,CAAO,CAAC,EAAM,EAAU,kBAAkB,CAAI,CAAA,EAAS,CAAA,EAAG,CAG5D,MAAO,CAAA,EAMb,IAAK,IAAI,EAAM,EAAG,EAAM,EAAU,kBAAkB,CAAG,EAAG,IACxD,IAAK,IAAI,EAAS,EAAG,EAAS,EAAU,kBAAkB,CAAE,IAM1D,GAAI,AALY,CAAO,CAAC,EAAM,EAAU,kBAAkB,CAAG,EAAO,GAGhE,CAAO,CAAE,AAAA,CAAA,EAAM,CAAA,EAAK,EAAU,kBAAkB,CAAG,EAAO,CAG5D,MAAO,CAAA,EAMb,MAAO,CAAA,CACT,EAMyB,IACvB,CAAA,IAAI,CAAC,MAAM,CAAG,EAAU,WAAW,AAAX,CAE5B,CACF,EAIE,eAAgB,CAClB,CAAA,EDphBM,IAAA,CAAA,EAAA,EAAA,cAAA,CACN,MAAM,EAAO,IAAb,EAEA,IAAI,EAAY,CAAA,EAGhB,MAAM,EAAQ,SAAS,aAAa,CAAC,eAC/B,EAAc,SAAS,aAAa,CAAC,iBACrC,EAAe,SAAS,aAAa,CAAC,kBACtC,EAAa,SAAS,aAAa,CAAC,gBACpC,EAAc,SAAS,aAAa,CAAC,iBAErC,EAAoB,IACrB,SAAS,gBAAgB,CAAC,eAAe,MAAM,GACnD,CAEK,EAAe,EAAE,CAEvB,IAAK,IAAI,EAAM,EAAG,EAAM,EAAe,kBAAkB,CAAE,IAAO,CAChE,CAAY,CAAC,EAAI,CAAG,AAAI,MAAM,EAAe,kBAAkB,EAE/D,IAAK,IAAI,EAAS,EAAG,EAAS,EAAe,kBAAkB,CAAE,IAC/D,CAAY,CAAC,EAAI,CAAC,EAAO,CACrB,CAAiB,CAAC,EAAM,EAAe,kBAAkB,CAAG,EAAO,AAE3E,CAwEA,SAAS,IACP,IAAK,IAAI,EAAM,EAAG,EAAM,EAAe,kBAAkB,CAAE,IACzD,IAAK,IAAI,EAAS,EAAG,EAAS,EAAe,kBAAkB,CAAE,IAAU,CACzE,IAAM,EAAW,CAAY,CAAC,EAAI,CAAC,EAAO,CACpC,EAAQ,EAAK,OAAO,CAAC,EAAK,GAEhC,IAAK,IAAI,EAAI,EAAG,GAAK,KAAM,GAAK,EAC9B,EAAS,SAAS,CAAC,MAAM,CAAC,CAAC,YAAY,EAAE,EAAE,CAAC,CAG1C,AAAU,CAAA,IAAV,EACF,EAAS,WAAW,CAAG,IAEvB,EAAS,WAAW,CAAG,CAAC,EAAE,EAAM,CAAC,CACjC,EAAS,SAAS,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,EAAM,CAAC,EAEjD,CAGF,EAAM,WAAW,CAAG,EAAK,QAAQ,GAAG,QAAQ,EAC9C,CAzFA,EAAa,OAAO,CAAC,CAAC,EAAK,KACzB,EAAI,OAAO,CAAC,CAAC,EAAS,KACpB,EAAQ,gBAAgB,CAAC,QAAS,KAChC,AAwFN,CAAA,SAA4B,CAAG,CAAE,CAAM,EACrC,GAAI,EAAW,CACb,IAAM,EAAI,EAAK,OAAO,CAAC,EAAK,EAExB,AAAM,CAAA,IAAN,EACF,EAAK,OAAO,CAAC,EAAK,EAAQ,GACjB,AAAM,OAAN,EACT,EAAK,OAAO,CAAC,EAAK,EAAQ,GAE1B,EAAK,OAAO,CAAC,EAAK,EAAQ,AAAI,EAAJ,GAG5B,GACF,CACF,CAAA,EAtGyB,EAAU,EAC/B,EACF,EACF,GAEA,EAAY,gBAAgB,CAAC,QAI7B,WACM,EAAY,SAAS,CAAC,QAAQ,CAAC,WACjC,EAAY,SAAS,CAAC,OAAO,CAAC,QAAS,WACvC,EAAY,WAAW,CAAG,UAE1B,EAAa,SAAS,CAAC,GAAG,CAAC,WAG7B,EAAW,SAAS,CAAC,GAAG,CAAC,UACzB,EAAY,SAAS,CAAC,GAAG,CAAC,UAE1B,EAAK,OAAO,GACZ,EAAK,KAAK,GACV,GACF,GAjBA,SAAS,gBAAgB,CAAC,UAmB1B,SAA6B,CAAO,EAClC,IAAI,EAAW,CAAA,EAEf,OAAQ,EAAQ,GAAG,EACjB,IAAK,aACH,EAAK,SAAS,GACd,KACF,KAAK,YACH,EAAK,QAAQ,GACb,KACF,KAAK,UACH,EAAK,MAAM,GACX,KACF,KAAK,YACH,EAAK,QAAQ,GACb,KACF,KAAK,KACH,EAAY,CAAC,EAEb,QAAQ,GAAG,CAAC,CAAC,YAAY,EAAE,EAAU,CAAC,EACtC,EAAW,CAAA,EACX,KACF,SACE,EAAW,CAAA,CAEf,CAEA,GAAI,EAAU,CACZ,OAAQ,EAAK,SAAS,IACpB,KAAK,EAAe,UAAU,CAC5B,EAAW,SAAS,CAAC,MAAM,CAAC,UAC5B,KACF,MAAK,EAAe,WAAW,CAC7B,EAAY,SAAS,CAAC,MAAM,CAAC,SAEjC,CAEA,GACF,CACF","sources":["<anon>","src/scripts/main.js","src/modules/Game.class.js"],"sourcesContent":["\"use strict\";\nvar $a5fd07fa01589658$exports = {};\n\"use strict\";\nconst $a5fd07fa01589658$var$CONSTANTS = Object.freeze({\n    PLAYING_FIELD_SIZE: 4,\n    STATUS_IDLE: \"idle\",\n    STATUS_PLAYING: \"playing\",\n    STATUS_WIN: \"win\",\n    STATUS_LOSE: \"lose\",\n    EMPTY_PLAYING_FIELD: Object.freeze([\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ]\n    ])\n});\nclass $a5fd07fa01589658$var$Game {\n    /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */ constructor(initialState = $a5fd07fa01589658$var$CONSTANTS.EMPTY_PLAYING_FIELD){\n        this.score = 0;\n        this.status = $a5fd07fa01589658$var$CONSTANTS.STATUS_IDLE;\n        this.initialState = [];\n        this.playingField = [];\n        for(let row = 0; row < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; row++){\n            this.initialState[row] = [];\n            this.playingField[row] = [];\n            for(let column = 0; column < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; column++){\n                this.initialState[row][column] = initialState[row][column];\n                this.playingField[row][column] = initialState[row][column];\n            }\n        }\n    }\n    /**\n   * Moves all cells left and compacts them,\n   * then updates the score and game status.\n   */ moveLeft() {\n        if (this.getStatus() !== $a5fd07fa01589658$var$CONSTANTS.STATUS_PLAYING) return;\n        let isTrivial = true;\n        for(let rowIndex = 0; rowIndex < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; rowIndex++){\n            const row = this.getRow(rowIndex);\n            const compactionResult = this.compactLine(row);\n            if (!this.areLinesEqual(row, compactionResult.compacted)) {\n                isTrivial = false;\n                this.setRow(rowIndex, compactionResult.compacted);\n                this.score += compactionResult.score;\n            }\n        }\n        if (!isTrivial) {\n            this.populateRandomly(1);\n            this.updateStatus();\n        }\n    }\n    /**\n   * Moves all cells right and compacts them,\n   * then updates the score and game status.\n   */ moveRight() {\n        if (this.getStatus() !== $a5fd07fa01589658$var$CONSTANTS.STATUS_PLAYING) return;\n        let isTrivial = true;\n        for(let rowIndex = 0; rowIndex < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; rowIndex++){\n            const row = this.getRow(rowIndex);\n            const compactionResult = this.compactLine(row.reverse());\n            if (!this.areLinesEqual(row, compactionResult.compacted)) {\n                isTrivial = false;\n                this.setRow(rowIndex, compactionResult.compacted.reverse());\n                this.score += compactionResult.score;\n            }\n        }\n        if (!isTrivial) {\n            this.populateRandomly(1);\n            this.updateStatus();\n        }\n    }\n    /**\n   * Moves all cells up and compacts them,\n   * then updates the score and game status.\n   */ moveUp() {\n        if (this.getStatus() !== $a5fd07fa01589658$var$CONSTANTS.STATUS_PLAYING) return;\n        let isTrivial = true;\n        for(let columnIndex = 0; columnIndex < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; columnIndex++){\n            const column = this.getColumn(columnIndex);\n            const compactionResult = this.compactLine(column);\n            if (!this.areLinesEqual(column, compactionResult.compacted)) {\n                isTrivial = false;\n                this.setColumn(columnIndex, compactionResult.compacted);\n                this.score += compactionResult.score;\n            }\n        }\n        if (!isTrivial) {\n            this.populateRandomly(1);\n            this.updateStatus();\n        }\n    }\n    /**\n   * Moves all cells down and compacts them,\n   * then updates the score and game status.\n   */ moveDown() {\n        if (this.getStatus() !== $a5fd07fa01589658$var$CONSTANTS.STATUS_PLAYING) return;\n        let isTrivial = true;\n        for(let columnIndex = 0; columnIndex < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; columnIndex++){\n            const column = this.getColumn(columnIndex);\n            const compactionResult = this.compactLine(column.reverse());\n            if (!this.areLinesEqual(column, compactionResult.compacted)) {\n                isTrivial = false;\n                this.setColumn(columnIndex, compactionResult.compacted.reverse());\n                this.score += compactionResult.score;\n            }\n        }\n        if (!isTrivial) {\n            this.populateRandomly(1);\n            this.updateStatus();\n        }\n    }\n    /**\n   * @returns {number}\n   */ getScore() {\n        return this.score;\n    }\n    /**\n   * @returns {number[][]}\n   */ getState() {\n        const result = new Array($a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE);\n        for(let row = 0; row < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; row++){\n            result[row] = new Array($a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE);\n            for(let column = 0; column < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; column++)result[row][column] = this.playingField[row][column];\n        }\n        return result;\n    }\n    /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */ getStatus() {\n        return this.status;\n    }\n    /**\n   * Starts the game.\n   */ start() {\n        this.status = $a5fd07fa01589658$var$CONSTANTS.STATUS_PLAYING;\n        this.score = 0;\n        this.populateRandomly(2);\n    }\n    /**\n   * Resets the game.\n   */ restart() {\n        for(let row = 0; row < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; row++)for(let column = 0; column < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; column++)this.playingField[row][column] = this.initialState[row][column];\n        this.status = $a5fd07fa01589658$var$CONSTANTS.STATUS_IDLE;\n        this.score = 0;\n    }\n    /**\n   * Returns a column by index;\n   * @param {number} index\n   */ getColumn(index) {\n        const column = new Array($a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE);\n        for(let row = 0; row < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; row++)column[row] = this.playingField[row][index];\n        return column;\n    }\n    /**\n   * Sets a column by index;\n   * @param {number} index\n   */ setColumn(index, column) {\n        for(let row = 0; row < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; row++)this.playingField[row][index] = column[row];\n    }\n    /**\n   * Returns a row by index.\n   *\n   * @param {number} index\n   */ getRow(index) {\n        const row = new Array($a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE);\n        for(let column = 0; column < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; column++)row[column] = this.playingField[index][column];\n        return row;\n    }\n    /**\n   * Sets a row by index.\n   *\n   * @param {number} index\n   */ setRow(index, row) {\n        for(let column = 0; column < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; column++)this.playingField[index][column] = row[column];\n    }\n    /**\n   * Returns a 1D array of all cell values. To get 2D version use {getState()}\n   *\n   * @returns {number[]}\n   */ getCells() {\n        const cells = this.playingField.reduce((acc, row)=>[\n                ...acc,\n                ...row\n            ], []);\n        return cells;\n    }\n    /**\n   * Returns a 1D array of {IndexedCell}\n   * that contain information about their position in the grid\n   * and their value.\n   *\n   * @typedef {Object} IndexedCell\n   * @property {number} row\n   * @property {number} column\n   * @property {number} value\n   *\n   * @returns {IndexedCell[]}\n   */ getIndexedCells() {\n        const indexedCells = this.getCells().map((value, index)=>{\n            const column = index % $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE;\n            const row = (index - column) / $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE;\n            return {\n                row: row,\n                column: column,\n                value: value\n            };\n        });\n        return indexedCells;\n    }\n    /**\n   * Returns a value of a specified game cell.\n   *\n   * @param {number} row\n   * @param {number} column\n   * @returns {number}\n   */ getCell(row, column) {\n        return this.playingField[row][column];\n    }\n    /**\n   * Sets a value of a specified game cell.\n   *\n   * @param {number} row\n   * @param {number} column\n   * @param {nunber} value\n   */ setCell(row, column, value) {\n        this.playingField[row][column] = value;\n    }\n    /**\n   * Fills some amount of random empty cells with values\n   *\n   * @param {number} count - how many cells to populate\n   */ populateRandomly(count) {\n        const emptyCells = this.getIndexedCells().filter(({ value: value })=>value === 0);\n        for(let i = 0; i < count; i++){\n            if (emptyCells.length === 0) break;\n            const index = Math.floor(Math.random() * emptyCells.length);\n            const { row: row, column: column } = emptyCells[index];\n            emptyCells.splice(index, 1);\n            this.setCell(row, column, this.generateCellValue());\n        }\n    }\n    /**\n   * Generates a cell value.\n   *\n   * @returns {number}\n   */ generateCellValue() {\n        const t = Math.random();\n        if (t > 0.9) return 4;\n        return 2;\n    }\n    /**\n   * Takes the line of numbers and merges equal adjacent cells together,\n   * then pads the result with 0 to {PLAYING_FIELD_SIZE}.\n   *\n   * @typedef {Object} CompactedLine\n   * @param {number[]} compacted\n   * @param {number} score\n   *\n   * @param {number[]} line - a line that needs compacting\n   *\n   * @returns {CompactedLine}\n   */ compactLine(line) {\n        const numbers = line.filter((item)=>item !== 0);\n        if (numbers.length < 2) {\n            this.padWithZeros(numbers);\n            return {\n                compacted: numbers,\n                score: 0\n            };\n        }\n        const compactedNumbers = [];\n        let compactingScore = 0;\n        for(let i = 0; i < numbers.length; i++){\n            const current = numbers[i];\n            const next = numbers[i + 1];\n            if (current === next) {\n                compactedNumbers.push(current * 2);\n                compactingScore += current * 2;\n                i++;\n            } else compactedNumbers.push(current);\n        }\n        this.padWithZeros(compactedNumbers);\n        return {\n            compacted: compactedNumbers,\n            score: compactingScore\n        };\n    }\n    /**\n   * Checks if two game lines are equal.\n   *\n   * @param {number[]} a\n   * @param {number[]} b\n   *\n   * @returns {boolean}\n   */ areLinesEqual(a, b) {\n        for(let i = 0; i < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; i++){\n            if (a[i] !== b[i]) return false;\n        }\n        return true;\n    }\n    /**\n   * Pads an array of numbers with 0 to {PLAYING_FIELD_SIZE}\n   * @param {number[]} line\n   * @returns {number[]}\n   */ padWithZeros(line) {\n        while(line.length < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE)line.push(0);\n        return line;\n    }\n    /**\n   * Checks if the game is won or lost, and sets {status} accordingly.\n   */ updateStatus() {\n        function winCondition(numbers) {\n            return numbers.some((number)=>number === 2048);\n        }\n        function loseCondition(numbers) {\n            // of some zeros are present, moves are possible\n            if (numbers.some((number)=>number === 0)) return false;\n            // else check if any hirizontal move is possible\n            for(let row = 0; row < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; row++)for(let column = 0; column < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE - 1; column++){\n                const current = numbers[row * $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE + column];\n                const next = numbers[row * $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE + (column + 1)];\n                if (current === next) return false;\n            }\n            // else check if any vertical move is possible\n            for(let row = 0; row < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE - 1; row++)for(let column = 0; column < $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE; column++){\n                const current = numbers[row * $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE + column];\n                const next = numbers[(row + 1) * $a5fd07fa01589658$var$CONSTANTS.PLAYING_FIELD_SIZE + column];\n                if (current === next) return false;\n            }\n            // if no moves are possible -- game is lost\n            return true;\n        }\n        const cells = this.getCells();\n        if (winCondition(cells)) this.status = $a5fd07fa01589658$var$CONSTANTS.STATUS_WIN;\n        else if (loseCondition(cells)) this.status = $a5fd07fa01589658$var$CONSTANTS.STATUS_LOSE;\n    }\n}\n$a5fd07fa01589658$exports = {\n    Game: $a5fd07fa01589658$var$Game,\n    GAME_CONSTANTS: $a5fd07fa01589658$var$CONSTANTS\n};\n\n\nvar $09e991522ca7e64e$require$Game = $a5fd07fa01589658$exports.Game;\nvar $09e991522ca7e64e$require$GAME_CONSTANTS = $a5fd07fa01589658$exports.GAME_CONSTANTS;\nconst $09e991522ca7e64e$var$game = new $09e991522ca7e64e$require$Game();\nlet $09e991522ca7e64e$var$debugMode = false;\n// Element queries\nconst $09e991522ca7e64e$var$score = document.querySelector(\".game-score\");\nconst $09e991522ca7e64e$var$startButton = document.querySelector(\".button.start\");\nconst $09e991522ca7e64e$var$messageStart = document.querySelector(\".message-start\");\nconst $09e991522ca7e64e$var$messageWin = document.querySelector(\".message-win\");\nconst $09e991522ca7e64e$var$messageLose = document.querySelector(\".message-lose\");\nconst $09e991522ca7e64e$var$playingFieldCells = [\n    ...document.querySelectorAll(\".field-cell\").values()\n];\nconst $09e991522ca7e64e$var$playingField = [];\nfor(let row = 0; row < $09e991522ca7e64e$require$GAME_CONSTANTS.PLAYING_FIELD_SIZE; row++){\n    $09e991522ca7e64e$var$playingField[row] = new Array($09e991522ca7e64e$require$GAME_CONSTANTS.PLAYING_FIELD_SIZE);\n    for(let column = 0; column < $09e991522ca7e64e$require$GAME_CONSTANTS.PLAYING_FIELD_SIZE; column++)$09e991522ca7e64e$var$playingField[row][column] = $09e991522ca7e64e$var$playingFieldCells[row * $09e991522ca7e64e$require$GAME_CONSTANTS.PLAYING_FIELD_SIZE + column];\n}\n// event listening\n$09e991522ca7e64e$var$playingField.forEach((row, rowIndex)=>{\n    row.forEach((element, columnIndex)=>{\n        element.addEventListener(\"click\", ()=>{\n            $09e991522ca7e64e$var$debugIncrementCell(rowIndex, columnIndex);\n        });\n    });\n});\n$09e991522ca7e64e$var$startButton.addEventListener(\"click\", $09e991522ca7e64e$var$startButtonClickHandler);\ndocument.addEventListener(\"keydown\", $09e991522ca7e64e$var$keydownEventHandler);\n// functions\nfunction $09e991522ca7e64e$var$startButtonClickHandler() {\n    if ($09e991522ca7e64e$var$startButton.classList.contains(\"start\")) {\n        $09e991522ca7e64e$var$startButton.classList.replace(\"start\", \"restart\");\n        $09e991522ca7e64e$var$startButton.textContent = \"Restart\";\n        $09e991522ca7e64e$var$messageStart.classList.add(\"hidden\");\n    }\n    $09e991522ca7e64e$var$messageWin.classList.add(\"hidden\");\n    $09e991522ca7e64e$var$messageLose.classList.add(\"hidden\");\n    $09e991522ca7e64e$var$game.restart();\n    $09e991522ca7e64e$var$game.start();\n    $09e991522ca7e64e$var$syncCellValues();\n}\nfunction $09e991522ca7e64e$var$keydownEventHandler(keydown) {\n    let needSync = true;\n    switch(keydown.key){\n        case \"ArrowRight\":\n            $09e991522ca7e64e$var$game.moveRight();\n            break;\n        case \"ArrowLeft\":\n            $09e991522ca7e64e$var$game.moveLeft();\n            break;\n        case \"ArrowUp\":\n            $09e991522ca7e64e$var$game.moveUp();\n            break;\n        case \"ArrowDown\":\n            $09e991522ca7e64e$var$game.moveDown();\n            break;\n        case \"F6\":\n            $09e991522ca7e64e$var$debugMode = !$09e991522ca7e64e$var$debugMode;\n            // eslint-disable-next-line no-console\n            console.log(`debug mode: ${$09e991522ca7e64e$var$debugMode}`);\n            needSync = false;\n            break;\n        default:\n            needSync = false;\n            break;\n    }\n    if (needSync) {\n        switch($09e991522ca7e64e$var$game.getStatus()){\n            case $09e991522ca7e64e$require$GAME_CONSTANTS.STATUS_WIN:\n                $09e991522ca7e64e$var$messageWin.classList.remove(\"hidden\");\n                break;\n            case $09e991522ca7e64e$require$GAME_CONSTANTS.STATUS_LOSE:\n                $09e991522ca7e64e$var$messageLose.classList.remove(\"hidden\");\n                break;\n        }\n        $09e991522ca7e64e$var$syncCellValues();\n    }\n}\nfunction $09e991522ca7e64e$var$syncCellValues() {\n    for(let row = 0; row < $09e991522ca7e64e$require$GAME_CONSTANTS.PLAYING_FIELD_SIZE; row++)for(let column = 0; column < $09e991522ca7e64e$require$GAME_CONSTANTS.PLAYING_FIELD_SIZE; column++){\n        const viewCell = $09e991522ca7e64e$var$playingField[row][column];\n        const value = $09e991522ca7e64e$var$game.getCell(row, column);\n        for(let n = 2; n <= 2048; n *= 2)viewCell.classList.remove(`field-cell--${n}`);\n        if (value === 0) viewCell.textContent = \"\";\n        else {\n            viewCell.textContent = `${value}`;\n            viewCell.classList.add(`field-cell--${value}`);\n        }\n    }\n    $09e991522ca7e64e$var$score.textContent = $09e991522ca7e64e$var$game.getScore().toString();\n}\nfunction $09e991522ca7e64e$var$debugIncrementCell(row, column) {\n    if ($09e991522ca7e64e$var$debugMode) {\n        const n = $09e991522ca7e64e$var$game.getCell(row, column);\n        if (n === 0) $09e991522ca7e64e$var$game.setCell(row, column, 2);\n        else if (n === 2048) $09e991522ca7e64e$var$game.setCell(row, column, 0);\n        else $09e991522ca7e64e$var$game.setCell(row, column, n * 2);\n        $09e991522ca7e64e$var$syncCellValues();\n    }\n}\n\n\n//# sourceMappingURL=index.57e80549.js.map\n","\"use strict\";\n\n// Is it just me, or this script is really ugly?\n\n// Model access\nconst { Game, GAME_CONSTANTS } = require(\"../modules/Game.class\");\nconst game = new Game();\n\nlet debugMode = false;\n\n// Element queries\nconst score = document.querySelector(\".game-score\");\nconst startButton = document.querySelector(\".button.start\");\nconst messageStart = document.querySelector(\".message-start\");\nconst messageWin = document.querySelector(\".message-win\");\nconst messageLose = document.querySelector(\".message-lose\");\n\nconst playingFieldCells = [\n  ...document.querySelectorAll(\".field-cell\").values(),\n];\n\nconst playingField = [];\n\nfor (let row = 0; row < GAME_CONSTANTS.PLAYING_FIELD_SIZE; row++) {\n  playingField[row] = new Array(GAME_CONSTANTS.PLAYING_FIELD_SIZE);\n\n  for (let column = 0; column < GAME_CONSTANTS.PLAYING_FIELD_SIZE; column++) {\n    playingField[row][column]\n      = playingFieldCells[row * GAME_CONSTANTS.PLAYING_FIELD_SIZE + column];\n  }\n}\n\n// event listening\nplayingField.forEach((row, rowIndex) => {\n  row.forEach((element, columnIndex) => {\n    element.addEventListener(\"click\", () => {\n      debugIncrementCell(rowIndex, columnIndex);\n    });\n  });\n});\n\nstartButton.addEventListener(\"click\", startButtonClickHandler);\ndocument.addEventListener(\"keydown\", keydownEventHandler);\n\n// functions\nfunction startButtonClickHandler() {\n  if (startButton.classList.contains(\"start\")) {\n    startButton.classList.replace(\"start\", \"restart\");\n    startButton.textContent = \"Restart\";\n\n    messageStart.classList.add(\"hidden\");\n  }\n\n  messageWin.classList.add(\"hidden\");\n  messageLose.classList.add(\"hidden\");\n\n  game.restart();\n  game.start();\n  syncCellValues();\n}\n\nfunction keydownEventHandler(keydown) {\n  let needSync = true;\n\n  switch (keydown.key) {\n    case \"ArrowRight\":\n      game.moveRight();\n      break;\n    case \"ArrowLeft\":\n      game.moveLeft();\n      break;\n    case \"ArrowUp\":\n      game.moveUp();\n      break;\n    case \"ArrowDown\":\n      game.moveDown();\n      break;\n    case \"F6\":\n      debugMode = !debugMode;\n      // eslint-disable-next-line no-console\n      console.log(`debug mode: ${debugMode}`);\n      needSync = false;\n      break;\n    default:\n      needSync = false;\n      break;\n  }\n\n  if (needSync) {\n    switch (game.getStatus()) {\n      case GAME_CONSTANTS.STATUS_WIN:\n        messageWin.classList.remove(\"hidden\");\n        break;\n      case GAME_CONSTANTS.STATUS_LOSE:\n        messageLose.classList.remove(\"hidden\");\n        break;\n    }\n\n    syncCellValues();\n  }\n}\n\nfunction syncCellValues() {\n  for (let row = 0; row < GAME_CONSTANTS.PLAYING_FIELD_SIZE; row++) {\n    for (let column = 0; column < GAME_CONSTANTS.PLAYING_FIELD_SIZE; column++) {\n      const viewCell = playingField[row][column];\n      const value = game.getCell(row, column);\n\n      for (let n = 2; n <= 2048; n *= 2) {\n        viewCell.classList.remove(`field-cell--${n}`);\n      }\n\n      if (value === 0) {\n        viewCell.textContent = \"\";\n      } else {\n        viewCell.textContent = `${value}`;\n        viewCell.classList.add(`field-cell--${value}`);\n      }\n    }\n  }\n\n  score.textContent = game.getScore().toString();\n}\n\nfunction debugIncrementCell(row, column) {\n  if (debugMode) {\n    const n = game.getCell(row, column);\n\n    if (n === 0) {\n      game.setCell(row, column, 2);\n    } else if (n === 2048) {\n      game.setCell(row, column, 0);\n    } else {\n      game.setCell(row, column, n * 2);\n    }\n\n    syncCellValues();\n  }\n}\n","\"use strict\";\n\nconst CONSTANTS = Object.freeze({\n  PLAYING_FIELD_SIZE: 4,\n  STATUS_IDLE: \"idle\",\n  STATUS_PLAYING: \"playing\",\n  STATUS_WIN: \"win\",\n  STATUS_LOSE: \"lose\",\n  EMPTY_PLAYING_FIELD: Object.freeze([\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n  ]),\n});\n\nclass Game {\n  /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */\n  constructor(initialState = CONSTANTS.EMPTY_PLAYING_FIELD) {\n    this.score = 0;\n    this.status = CONSTANTS.STATUS_IDLE;\n    this.initialState = [];\n    this.playingField = [];\n\n    for (let row = 0; row < CONSTANTS.PLAYING_FIELD_SIZE; row++) {\n      this.initialState[row] = [];\n      this.playingField[row] = [];\n\n      for (let column = 0; column < CONSTANTS.PLAYING_FIELD_SIZE; column++) {\n        this.initialState[row][column] = initialState[row][column];\n        this.playingField[row][column] = initialState[row][column];\n      }\n    }\n  }\n\n  /**\n   * Moves all cells left and compacts them,\n   * then updates the score and game status.\n   */\n  moveLeft() {\n    if (this.getStatus() !== CONSTANTS.STATUS_PLAYING) {\n      return;\n    }\n\n    let isTrivial = true;\n\n    for (\n      let rowIndex = 0;\n      rowIndex < CONSTANTS.PLAYING_FIELD_SIZE;\n      rowIndex++\n    ) {\n      const row = this.getRow(rowIndex);\n\n      const compactionResult = this.compactLine(row);\n\n      if (!this.areLinesEqual(row, compactionResult.compacted)) {\n        isTrivial = false;\n\n        this.setRow(rowIndex, compactionResult.compacted);\n        this.score += compactionResult.score;\n      }\n    }\n\n    if (!isTrivial) {\n      this.populateRandomly(1);\n      this.updateStatus();\n    }\n  }\n\n  /**\n   * Moves all cells right and compacts them,\n   * then updates the score and game status.\n   */\n  moveRight() {\n    if (this.getStatus() !== CONSTANTS.STATUS_PLAYING) {\n      return;\n    }\n\n    let isTrivial = true;\n\n    for (\n      let rowIndex = 0;\n      rowIndex < CONSTANTS.PLAYING_FIELD_SIZE;\n      rowIndex++\n    ) {\n      const row = this.getRow(rowIndex);\n\n      const compactionResult = this.compactLine(row.reverse());\n\n      if (!this.areLinesEqual(row, compactionResult.compacted)) {\n        isTrivial = false;\n\n        this.setRow(rowIndex, compactionResult.compacted.reverse());\n        this.score += compactionResult.score;\n      }\n    }\n\n    if (!isTrivial) {\n      this.populateRandomly(1);\n      this.updateStatus();\n    }\n  }\n\n  /**\n   * Moves all cells up and compacts them,\n   * then updates the score and game status.\n   */\n  moveUp() {\n    if (this.getStatus() !== CONSTANTS.STATUS_PLAYING) {\n      return;\n    }\n\n    let isTrivial = true;\n\n    for (\n      let columnIndex = 0;\n      columnIndex < CONSTANTS.PLAYING_FIELD_SIZE;\n      columnIndex++\n    ) {\n      const column = this.getColumn(columnIndex);\n\n      const compactionResult = this.compactLine(column);\n\n      if (!this.areLinesEqual(column, compactionResult.compacted)) {\n        isTrivial = false;\n\n        this.setColumn(columnIndex, compactionResult.compacted);\n        this.score += compactionResult.score;\n      }\n    }\n\n    if (!isTrivial) {\n      this.populateRandomly(1);\n      this.updateStatus();\n    }\n  }\n\n  /**\n   * Moves all cells down and compacts them,\n   * then updates the score and game status.\n   */\n  moveDown() {\n    if (this.getStatus() !== CONSTANTS.STATUS_PLAYING) {\n      return;\n    }\n\n    let isTrivial = true;\n\n    for (\n      let columnIndex = 0;\n      columnIndex < CONSTANTS.PLAYING_FIELD_SIZE;\n      columnIndex++\n    ) {\n      const column = this.getColumn(columnIndex);\n\n      const compactionResult = this.compactLine(column.reverse());\n\n      if (!this.areLinesEqual(column, compactionResult.compacted)) {\n        isTrivial = false;\n\n        this.setColumn(columnIndex, compactionResult.compacted.reverse());\n        this.score += compactionResult.score;\n      }\n    }\n\n    if (!isTrivial) {\n      this.populateRandomly(1);\n      this.updateStatus();\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  getScore() {\n    return this.score;\n  }\n\n  /**\n   * @returns {number[][]}\n   */\n  getState() {\n    const result = new Array(CONSTANTS.PLAYING_FIELD_SIZE);\n\n    for (let row = 0; row < CONSTANTS.PLAYING_FIELD_SIZE; row++) {\n      result[row] = new Array(CONSTANTS.PLAYING_FIELD_SIZE);\n\n      for (let column = 0; column < CONSTANTS.PLAYING_FIELD_SIZE; column++) {\n        result[row][column] = this.playingField[row][column];\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */\n  getStatus() {\n    return this.status;\n  }\n\n  /**\n   * Starts the game.\n   */\n  start() {\n    this.status = CONSTANTS.STATUS_PLAYING;\n    this.score = 0;\n\n    this.populateRandomly(2);\n  }\n\n  /**\n   * Resets the game.\n   */\n  restart() {\n    for (let row = 0; row < CONSTANTS.PLAYING_FIELD_SIZE; row++) {\n      for (let column = 0; column < CONSTANTS.PLAYING_FIELD_SIZE; column++) {\n        this.playingField[row][column] = this.initialState[row][column];\n      }\n    }\n\n    this.status = CONSTANTS.STATUS_IDLE;\n    this.score = 0;\n  }\n\n  /**\n   * Returns a column by index;\n   * @param {number} index\n   */\n  getColumn(index) {\n    const column = new Array(CONSTANTS.PLAYING_FIELD_SIZE);\n\n    for (let row = 0; row < CONSTANTS.PLAYING_FIELD_SIZE; row++) {\n      column[row] = this.playingField[row][index];\n    }\n\n    return column;\n  }\n\n  /**\n   * Sets a column by index;\n   * @param {number} index\n   */\n  setColumn(index, column) {\n    for (let row = 0; row < CONSTANTS.PLAYING_FIELD_SIZE; row++) {\n      this.playingField[row][index] = column[row];\n    }\n  }\n\n  /**\n   * Returns a row by index.\n   *\n   * @param {number} index\n   */\n  getRow(index) {\n    const row = new Array(CONSTANTS.PLAYING_FIELD_SIZE);\n\n    for (let column = 0; column < CONSTANTS.PLAYING_FIELD_SIZE; column++) {\n      row[column] = this.playingField[index][column];\n    }\n\n    return row;\n  }\n\n  /**\n   * Sets a row by index.\n   *\n   * @param {number} index\n   */\n  setRow(index, row) {\n    for (let column = 0; column < CONSTANTS.PLAYING_FIELD_SIZE; column++) {\n      this.playingField[index][column] = row[column];\n    }\n  }\n\n  /**\n   * Returns a 1D array of all cell values. To get 2D version use {getState()}\n   *\n   * @returns {number[]}\n   */\n  getCells() {\n    const cells = this.playingField.reduce((acc, row) => [...acc, ...row], []);\n\n    return cells;\n  }\n\n  /**\n   * Returns a 1D array of {IndexedCell}\n   * that contain information about their position in the grid\n   * and their value.\n   *\n   * @typedef {Object} IndexedCell\n   * @property {number} row\n   * @property {number} column\n   * @property {number} value\n   *\n   * @returns {IndexedCell[]}\n   */\n  getIndexedCells() {\n    const indexedCells = this.getCells().map((value, index) => {\n      const column = index % CONSTANTS.PLAYING_FIELD_SIZE;\n      const row = (index - column) / CONSTANTS.PLAYING_FIELD_SIZE;\n\n      return {\n        row,\n        column,\n        value,\n      };\n    });\n\n    return indexedCells;\n  }\n\n  /**\n   * Returns a value of a specified game cell.\n   *\n   * @param {number} row\n   * @param {number} column\n   * @returns {number}\n   */\n  getCell(row, column) {\n    return this.playingField[row][column];\n  }\n\n  /**\n   * Sets a value of a specified game cell.\n   *\n   * @param {number} row\n   * @param {number} column\n   * @param {nunber} value\n   */\n  setCell(row, column, value) {\n    this.playingField[row][column] = value;\n  }\n\n  /**\n   * Fills some amount of random empty cells with values\n   *\n   * @param {number} count - how many cells to populate\n   */\n  populateRandomly(count) {\n    const emptyCells = this.getIndexedCells().filter(\n      ({ value }) => value === 0,\n    );\n\n    for (let i = 0; i < count; i++) {\n      if (emptyCells.length === 0) {\n        break;\n      }\n\n      const index = Math.floor(Math.random() * emptyCells.length);\n      const { row, column } = emptyCells[index];\n\n      emptyCells.splice(index, 1);\n\n      this.setCell(row, column, this.generateCellValue());\n    }\n  }\n\n  /**\n   * Generates a cell value.\n   *\n   * @returns {number}\n   */\n  generateCellValue() {\n    const t = Math.random();\n\n    if (t > 0.9) {\n      return 4;\n    }\n\n    return 2;\n  }\n\n  /**\n   * Takes the line of numbers and merges equal adjacent cells together,\n   * then pads the result with 0 to {PLAYING_FIELD_SIZE}.\n   *\n   * @typedef {Object} CompactedLine\n   * @param {number[]} compacted\n   * @param {number} score\n   *\n   * @param {number[]} line - a line that needs compacting\n   *\n   * @returns {CompactedLine}\n   */\n  compactLine(line) {\n    const numbers = line.filter((item) => item !== 0);\n\n    if (numbers.length < 2) {\n      this.padWithZeros(numbers);\n\n      return {\n        compacted: numbers,\n        score: 0,\n      };\n    }\n\n    const compactedNumbers = [];\n    let compactingScore = 0;\n\n    for (let i = 0; i < numbers.length; i++) {\n      const current = numbers[i];\n      const next = numbers[i + 1];\n\n      if (current === next) {\n        compactedNumbers.push(current * 2);\n        compactingScore += current * 2;\n        i++;\n      } else {\n        compactedNumbers.push(current);\n      }\n    }\n\n    this.padWithZeros(compactedNumbers);\n\n    return {\n      compacted: compactedNumbers,\n      score: compactingScore,\n    };\n  }\n\n  /**\n   * Checks if two game lines are equal.\n   *\n   * @param {number[]} a\n   * @param {number[]} b\n   *\n   * @returns {boolean}\n   */\n  areLinesEqual(a, b) {\n    for (let i = 0; i < CONSTANTS.PLAYING_FIELD_SIZE; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Pads an array of numbers with 0 to {PLAYING_FIELD_SIZE}\n   * @param {number[]} line\n   * @returns {number[]}\n   */\n  padWithZeros(line) {\n    while (line.length < CONSTANTS.PLAYING_FIELD_SIZE) {\n      line.push(0);\n    }\n\n    return line;\n  }\n\n  /**\n   * Checks if the game is won or lost, and sets {status} accordingly.\n   */\n  updateStatus() {\n    function winCondition(numbers) {\n      return numbers.some((number) => number === 2048);\n    }\n\n    function loseCondition(numbers) {\n      // of some zeros are present, moves are possible\n      if (numbers.some((number) => number === 0)) {\n        return false;\n      }\n\n      // else check if any hirizontal move is possible\n      for (let row = 0; row < CONSTANTS.PLAYING_FIELD_SIZE; row++) {\n        for (\n          let column = 0;\n          column < CONSTANTS.PLAYING_FIELD_SIZE - 1;\n          column++\n        ) {\n          const current = numbers[row * CONSTANTS.PLAYING_FIELD_SIZE + column];\n\n          const next\n            = numbers[row * CONSTANTS.PLAYING_FIELD_SIZE + (column + 1)];\n\n          if (current === next) {\n            return false;\n          }\n        }\n      }\n\n      // else check if any vertical move is possible\n      for (let row = 0; row < CONSTANTS.PLAYING_FIELD_SIZE - 1; row++) {\n        for (let column = 0; column < CONSTANTS.PLAYING_FIELD_SIZE; column++) {\n          const current = numbers[row * CONSTANTS.PLAYING_FIELD_SIZE + column];\n\n          const next\n            = numbers[(row + 1) * CONSTANTS.PLAYING_FIELD_SIZE + column];\n\n          if (current === next) {\n            return false;\n          }\n        }\n      }\n\n      // if no moves are possible -- game is lost\n      return true;\n    }\n\n    const cells = this.getCells();\n\n    if (winCondition(cells)) {\n      this.status = CONSTANTS.STATUS_WIN;\n    } else if (loseCondition(cells)) {\n      this.status = CONSTANTS.STATUS_LOSE;\n    }\n  }\n}\n\nmodule.exports = {\n  Game,\n  GAME_CONSTANTS: CONSTANTS,\n};\n"],"names":["$a5fd07fa01589658$exports","$a5fd07fa01589658$var$CONSTANTS","Object","freeze","PLAYING_FIELD_SIZE","STATUS_IDLE","STATUS_PLAYING","STATUS_WIN","STATUS_LOSE","EMPTY_PLAYING_FIELD","$09e991522ca7e64e$require$Game","Game","constructor","initialState","score","status","playingField","row","column","moveLeft","getStatus","isTrivial","rowIndex","getRow","compactionResult","compactLine","areLinesEqual","compacted","setRow","populateRandomly","updateStatus","moveRight","reverse","moveUp","columnIndex","getColumn","setColumn","moveDown","getScore","getState","result","Array","start","restart","index","getCells","reduce","acc","getIndexedCells","map","value","getCell","setCell","count","emptyCells","filter","i","length","Math","floor","random","splice","generateCellValue","t","line","numbers","item","padWithZeros","compactedNumbers","compactingScore","current","push","a","b","cells","some","number","loseCondition","GAME_CONSTANTS","$09e991522ca7e64e$require$GAME_CONSTANTS","$09e991522ca7e64e$var$game","$09e991522ca7e64e$var$debugMode","$09e991522ca7e64e$var$score","document","querySelector","$09e991522ca7e64e$var$startButton","$09e991522ca7e64e$var$messageStart","$09e991522ca7e64e$var$messageWin","$09e991522ca7e64e$var$messageLose","$09e991522ca7e64e$var$playingFieldCells","querySelectorAll","values","$09e991522ca7e64e$var$playingField","$09e991522ca7e64e$var$syncCellValues","viewCell","n","classList","remove","textContent","add","toString","forEach","element","addEventListener","$09e991522ca7e64e$var$debugIncrementCell","contains","replace","keydown","needSync","key","console","log"],"version":3,"file":"index.57e80549.js.map"}